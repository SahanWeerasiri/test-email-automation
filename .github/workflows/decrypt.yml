name: Issue-Based PGP Decryption

on:
  issues:
    types: [opened]

jobs:
  decrypt: 
    # Only run if the issue title starts with "DECRYPT"
    if: startsWith(github. event.issue.title, 'DECRYPT')

    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      issues: write # Needed for commenting and closing the issue

    steps:
      - name: üîç Extract Encrypted Content from Issue Body
        id: parse_issue
        run: |
          # Use awk to find and extract the full PGP MESSAGE block
          ENCRYPTED_DATA=$(echo "${{ github.event.issue.body }}" | awk '/-----BEGIN PGP MESSAGE-----/,/-----END PGP MESSAGE-----/')
          
          if [ -z "$ENCRYPTED_DATA" ]; then
            echo "::error:: Could not find PGP MESSAGE block in the issue body."
            echo "ENCRYPTED_CONTENT_FOUND=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "ENCRYPTED_CONTENT_FOUND=true" >> $GITHUB_OUTPUT
          # Save the data to a temporary file for the gpg command
          echo "$ENCRYPTED_DATA" > encrypted.pgp
        
      - name: üîê Setup GnuPG, Import Key, and Test Passphrase (Diagnostic Included)
        id: setup_test
        if: success() && steps.parse_issue.outputs.ENCRYPTED_CONTENT_FOUND == 'true'
        env: 
          PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
          
        run:  |
          # --- Environment Setup ---
          export GNUPGHOME=$(mktemp -d)
          echo "GPG Home set to: $GNUPGHOME"
          echo "GNUPGHOME=$GNUPGHOME" >> $GITHUB_ENV 
          
          # --- Key Identification ---
          KEY_ID="test-server@example.com" # Using your provided test key ID
          echo "Key ID being used: $KEY_ID"
          
          # 1. Import the Private Key
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import
          
          # 2. Test Private Key and Passphrase Combination (Reliability Check)
          echo "${{ secrets.GPG_PASSPHRASE }}" > pass_test.txt
          chmod 600 pass_test.txt

          echo "Running passphrase/key access test..."
          TEST_OUTPUT=$(gpg --batch --passphrase-fd 3 --list-secret-keys --with-key-data "$KEY_ID" 3<pass_test.txt 2>&1)
          TEST_STATUS=$?
          rm pass_test.txt 
          
          if [ $TEST_STATUS -ne 0 ]; then
              echo "::error::Private key access failed! Passphrase or GPG_PRIVATE_KEY secret is incorrect."
              echo "GPG Output: $TEST_OUTPUT"
              exit 1 
          fi
          echo "Passphrase test succeeded."

          # 3. FIX: Set the key to ultimate trust non-interactively
          # Uses the most reliable method (awk on 'fpr' marker) for the fingerprint
          KEY_FINGERPRINT=$(gpg --list-secret-keys --with-colons "$KEY_ID" | awk -F:  '$1 == "fpr" {print $10; exit}')
          
          if [ -n "$KEY_FINGERPRINT" ]; then
            echo "Setting ultimate trust (level 6) for fingerprint: $KEY_FINGERPRINT"
            echo "$KEY_FINGERPRINT:6:" | gpg --import-ownertrust
            echo "Key trust successfully updated."
          else
            echo ":: error::Could not find key fingerprint. Trust cannot be set."
            exit 1
          fi
          
      - name: üîë Decrypt Content (Uses reliable FD Passphrase Method)
        id: decrypt_step
        if: success()
        env:
          PASSPHRASE:  ${{ secrets.GPG_PASSPHRASE }}
          
        run: |
          set +e  # Disable exit on error for this step to handle failures gracefully
          
          # 1. Write the passphrase to a temporary file for reliable passing via FD
          echo "$PASSPHRASE" > passphrase.txt
          chmod 600 passphrase.txt

          # 2. Attempt decryption, capturing both stdout and stderr
          DECRYPTED_RESULT=$(gpg --batch --passphrase-fd 3 --output - --decrypt encrypted.pgp 3<passphrase.txt 2>&1)
          DECRYPT_EXIT_CODE=$?
          
          # 3. Clean up the passphrase file immediately
          rm passphrase.txt

          # 4. Check decryption status
          if [ $DECRYPT_EXIT_CODE -ne 0 ]; then
            echo ":: warning::Decryption failed with exit code $DECRYPT_EXIT_CODE"
            echo "DECRYPTED_CONTENT=Decryption failed. The message may not be encrypted to the correct public key, or there was an error processing the encrypted message." >> $GITHUB_OUTPUT
            echo "DECRYPT_STATUS=failed" >> $GITHUB_OUTPUT
          else
            echo "Decryption succeeded."
            # Use delimiter to safely capture multi-line output
            {
              echo "DECRYPTED_CONTENT<<EOF"
              echo "$DECRYPTED_RESULT"
              echo "EOF"
            } >> $GITHUB_OUTPUT
            echo "DECRYPT_STATUS=success" >> $GITHUB_OUTPUT
          fi
          
      - name: üí¨ Comment Decryption Result
        uses: peter-evans/create-or-update-comment@v3 # Used ONLY for commenting
        if: always()
        with:
          issue-number: ${{ github.event.issue.number }}
          body: |
            ## üîì PGP Decryption Status: ${{ steps.decrypt_step.outputs.DECRYPT_STATUS }}
            
            ${{ steps. decrypt_step.outputs.DECRYPT_STATUS == 'success' && '### Decrypted Content' || ''}}
            
            ```plaintext
            ${{ steps. decrypt_step.outputs.DECRYPTED_CONTENT }}
            ```
            
            ---
            *Note: This message was automatically generated by the Decryption GitHub Action.*

      - name: ‚ùå Close Issue on Successful Decryption
        uses: peter-evans/close-issue@v3 # Used dedicated action to close the issue
        if: success() && steps.decrypt_step.outputs.DECRYPT_STATUS == 'success'
        with:
          issue-number: ${{ github. event.issue.number }}
          comment: "Decryption successfully completed. Closing this issue."
          
      - name: üóëÔ∏è Cleanup
        # Remove the temporary GPG home directory immediately
        if: always()
        run: rm -rf "${{ env.GNUPGHOME }}"
        env:
          GNUPGHOME: ${{ env.GNUPGHOME }}
